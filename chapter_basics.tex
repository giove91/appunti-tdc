\chapter{Definizioni}

\section{Sintassi e semantica}

\section{Macchine di Turing}
Una macchina di Turing può essere immaginata come un dispositivo libero di
muoversi su un nastro infinito sul quale in ogni istante possono essere scritti
finiti simboli appartenenti ad un alfabeto finito. La macchina di Turing è
dotata di uno \emph{stato}, e lavora nel modo seguente:
\begin{enumerate}
 \item Legge il simbolo scritto sul nastro nella posizione in cui si trova attualmente.
 \item Controlla in una tabella finita memorizzata al suo interno cosa deve fare
 nel quando legge quel simbolo nello stato in cui si trova.
 \item Basandosi su quello che ha letto nella tabella scrive un simbolo sul nastro,
 si sposta a destra o a sinistra e passa in un nuovo stato.
 \item Se lo stato in cui si trova ora è uno stato speciale, chiamato \emph{terminale},
 la macchina si ferma. Altrimenti il processo reinizia.
\end{enumerate}
All'istante zero la macchina si trova in uno stato speciale detto \emph{iniziale}
e sul nastro può essere già scritta una stringa finita detta \emph{input} della macchina.
Diamo ora la definizione formale.
\begin{definizione}
Si dice macchina di Turing una tupla
$M=\langle Q, \Gamma, b, \delta, q_0, F, F_y \rangle$ dove:
\begin{enumerate}
 \item $Q$ è un insieme finito non vuoto di \emph{stati};
 \item $\Gamma$ è un insieme finito di simboli, detto \emph{alfabeto} della macchina;
 \item $b \in \Gamma$ è un simbolo speciale, detto \emph{blank}, che rappresenta
 una cella vuota;
 \item $q_0 \in Q$ è lo \emph{stato iniziale};
 \item $F \subseteq Q$ è un insieme di \emph{stati terminali};
 \item $F_y \subseteq F$ è un insieme di stati terminali \emph{accettanti};
 \item $\delta: Q \times \Gamma \to Q \times \Gamma \times \{\texttt{L},\texttt{R}\}$
 è una funzione parziale detta \emph{funzione di transizione}.
\end{enumerate}
\end{definizione}

\begin{definizione}
 Data una macchina di Turing $M=\langle Q, \Gamma, b, \delta, q_0, F, F_y \rangle$,
 chiamiamo configurazione della macchina una tripla
 $\langle q, S, n \rangle$ dove:
 \begin{enumerate}
  \item $q \in Q$ rappresenta lo stato in cui si trova attualmente la macchina;
  \item $S \in \Gamma ^ \Z$, con $S(k)=b$ per tutti tranne al più finiti $k \in Z$,
  rappresenta lo stato attuale del nastro;
  \item $n \in \Z$ rappresenta la posizione attuale della macchina di Turing
  sul nastro.
 \end{enumerate}
\end{definizione}
Nel seguito useremo la seguente notazione più compatta per descrivere la
configurazione di una macchina di Turing:
\begin{definizione}
 Data una macchina di Turing $M=\langle Q, \Gamma, b, \delta, q_0, F, F_y \rangle$,
 chiamiamo configurazione della macchina una funzione
 $S: \Z \to (\Gamma \sqcup \Gamma \times Q)$  tale che $S(k)=b$ per
 tutti tranne al più finiti $k \in Z$ ed esiste unico $n \in Z$ con
 $S(n) = (\gamma, q) \in \Gamma \times Q$.
 $S$ rappresenta lo il contenuto attuale del nastro, $n$ la posizione della
 macchina di Turing e $q$ il suo stato nella configurazione $S$.
\end{definizione}

\begin{definizione}
 Sia data una macchina di Turing $M=\langle Q, \Gamma, b, \delta, q_0, F, F_y \rangle$
 e due sue configurazioni $S$ e $S'$.
 Siano $n \in \Z$, $\gamma \in \Gamma$, $q \in Q$ gli unici tali che
 $S(n) = (\gamma, q)$ e supponiamo $\delta(\gamma, q) = (q', \gamma', \texttt{R})$.
 Diciamo che
 $M$ può fare la transizione da $S$ a $S'$, e lo indichiamo con $S \vdash_M S'$,
 se 
 \begin{enumerate}
  \item $S'(n)=\gamma'$;
  \item $S'(n+1)=(\sigma, q')$ per un
 qualche $\sigma \in \Gamma$;
  \item $S(k) = S'(k)$ per ogni $k \in \Z$ diverso da
 $n$ e $n+1$.
 \end{enumerate}
 Similmente si dà la definizaione nel caso in cui
 $\delta(\gamma, q) = (q', \gamma', \texttt{L})$,
 sostituendo ovunque $n+1$ con $n-1$.
\end{definizione}

\begin{osservazione}
 Per ogni configurazione $S$ della macchina di Turing $M$, esiste al più una
 $S'$ tale che $S \vdash_M S'$, da cui l'aggettivo \emph{deterministica}.
\end{osservazione}

\begin{definizione}
 Data una macchina di Turing $M$ e due sue configurazioni $S$ e $S'$ diciamo
 che $S \vdash_M^{0} S'$ se $S = S'$ e diciamo che
 $S \vdash_M^{n+1} S'$ se esiste una configurazione $S_0$ tale che
 $S \vdash_M S_0$ e $S_0 \vdash_M^{n} S'$. Diciamo poi che $S \vdash_M^{\ast} S'$
 se esiste $n \in \N$ tale che $S \vdash_M^{n} S'$.
\end{definizione}

\begin{definizione}
 Una configurazione $S$ di una macchina di Turing
 $M=\langle Q, \Gamma, b, \delta, q_0, F \rangle$ si dice \emph{iniziale} se
 $S(0) = (\gamma, q_0)$. In tal caso, il contenuto del nastro
 si dice \emph{input} della macchina di Turing e questo determina totalmente
 una configurazione iniziale.
 Una configurazione $S$ si dice \emph{terminale} se lo stato della macchina
 di Turing nella configurazione $S$ è terminale e accettante se lo stato è
 accettante.
\end{definizione}

\begin{definizione}
 Sia $S_w$ la configurazione iniziale con input $w \in S^\ast$. Diciamo che
 una macchina di Turing termina con input $w$, e lo indichiamo con $M(w)\downarrow$
 se esiste $S'$ terminale tale che $S \vdash_M^\ast S'$. Diciamo che
 $M$ accetta l'input $w$, e lo indichiamo con $M(w)\downarrow_y$ se
 esiste $S'$ terminale accettante tale che $S \vdash_M^\ast S'$.
\end{definizione}

\begin{definizione}
 Dato un alfabeto $S$, chiamiamo \emph{problema} un insieme di stringhe finite
 $P \subseteq S^\ast$. Diciamo che il problema $P$ è calcolabile dalla macchina
 di Turing $M$ se, per ogni $w$ in $S^\ast$, $M$ accetta $w$ se e solo se $w$
 è in $P$. Diciamo che il problema $P$ è calcolabile se è calcolabile da una
 macchina di Turing.
\end{definizione}

Esistono varianti della definizione di macchina di Turing che, pur non cambiano
l'insieme dei problemi calcolabili, sono più semplici da adoperare in alcuni
casi. Una variante che sarà molto importante per noi sono le
\emph{macchine di Turing a $k$-nastri}.

\section{Codifica e decodifica}
Sia $L=\{R^{a_1}_1, \ldots, R^{a_s}_s, c_1, \ldots, c_l\}$ un linguaggio.
Vogliamo fornire un modo standard di codificare una $L$-struttura finita $A$ come
stringa binaria, che denoteremo $\bin(A)$. Nel seguito supporremo sempre, senza
perdita di generalità, che
il dominio di una $L$-struttura finita sia un insieme del tipo
$\{1,\ldots,n\} \subseteq \N$.

\begin{definizione}
  Sia $A$ una $L$-struttura, con $|A| = n < +\infty$.
  Se $R \subseteq A^k$ è una relazione,
  definiamo $\bin(R): |A|^k \to \{0,1\}$ come:
  \[\bin(R)(a_1 + a_2 \cdot n + a_k \cdot n^{k-1}):=
    \begin{cases}
      1 \mbox{ se } R(a_1,\ldots,a_k) \\
      0 \mbox{ altrimenti}
    \end{cases}
  \]
  Se $a$ è un elemento di $A=\{1,\ldots,n\}$, definiamo $\bin(a)$ essere la
  scrittura binaria del numero $a$, con eventualmente aggiunti degli zeri a
  sinistra affinché abbia lunghezza esattamente $\lceil \log_2(n) \rceil$.
  Definiamo infine
  \[\bin(A):=\bin(R_1)\string^\ldots\string^\bin(R_s)\string^\bin(c_1)\string^\ldots\string^\bin(c_l).\]
\end{definizione}

\begin{osservazione}
\label{oss-bin}
 Detta $n$ la cardinalità di $A$, la lunghezza della codifica è
 \[ |\bin(A)|=n^{a_1} + \ldots + n^{a_s} + l \cdot \lceil \log_2(n) \rceil, \]
 e in particolare è polinomiale in $n$. Inoltre dato che la parte a destra è
 strettamente crescente in $n$, questo ci dice che, conoscendo solo il linguaggio,
 e $\bin(A)$, possiamo ricavare $n$ e più in generale possiamo ricostruire tutto $A$.
 Infatti avremo che vale $R_i^A(x_1,\ldots, x_{a_i})$ se e solo se
 $\bin(A)(n^{a_1} + \ldots + n^{a_{i-1}} + x_1 + x_2 \cdot n + \ldots + x_{a_i} \cdot n^{a_i-1}) = 1$.
\end{osservazione}
Useremo questa procedura principalmente per descrivere modelli all'interno
di macchine di Turing. Infatti, come notato nell'Osservazione \ref{oss-bin},
una macchina di Turing può ricostruire
il valore della relazione $R_i^A(x_1, \ldots, x_{a_i})$ calcolando il valore
di $n$ e spostando la testina e leggendo il valore nella posizione
$n^{a_1} + \ldots + n^{a_{i-1}} + x_1 + x_2 \cdot n + \ldots + x_{a_i} \cdot n^{a_i-1}$
del blocco di memoria corrispondente alla codifica.
Nello pseudo-codice indicheremo questa procedura con
$\decode_{R_i}(\bin(A), x_1, \ldots, x_{a_i})$. La corrispondente procedura per
leggere il valore di una costante sarà indicata con $\decode_{c_i} (\bin(A))$.

