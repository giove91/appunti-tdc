\chapter{Definizioni}

\section{Sintassi e semantica}

\section{Macchine di Turing}
Una macchina di Turing può essere immaginata come un dispositivo libero di
muoversi su un nastro infinito sul quale in ogni istante possono essere scritti
finiti simboli appartenenti ad un alfabeto finito. La macchina di Turing è
dotata di uno \emph{stato}, e lavora nel modo seguente:
\begin{enumerate}
 \item Legge il simbolo scritto sul nastro nella posizione in cui si trova attualmente.
 \item Controlla in una tabella finita memorizzata al suo interno cosa deve fare
 nel quando legge quel simbolo nello stato in cui si trova.
 \item Basandosi su quello che ha letto nella tabella scrive un simbolo sul nastro,
 si sposta a destra o a sinistra e passa in un nuovo stato.
 \item Se lo stato in cui si trova ora è uno stato speciale, chiamato \emph{terminale},
 la macchina si ferma. Altrimenti il processo reinizia.
\end{enumerate}
All'istante zero la macchina si trova in uno stato speciale detto \emph{iniziale}
e sul nastro può essere già scritta una stringa finita detta \emph{input} della macchina.
Diamo ora la definizione formale.
\begin{definizione}
Si dice macchina di Turing una 6-upla
$M=\langle Q, \Gamma, b, \delta, q_0, F \rangle$ dove:
\begin{enumerate}
 \item $Q$ è un insieme finito non vuoto di \emph{stati};
 \item $\Gamma$ è un insieme finito di simboli, detto \emph{alfabeto} della macchina;
 \item $b \in \Gamma$ è un simbolo speciale, detto \emph{blank}, che rappresenta
 una cella vuota;
 \item $q_0 \in Q$ è lo \emph{stato iniziale};
 \item $F \subseteq Q$ è un insieme di \emph{stati terminali};
 \item $\delta: Q \times \Gamma \to Q \times \Gamma \times \{\texttt{L},\texttt{R}\}$
 è una funzione parziale detta \emph{funzione di transizione}.
\end{enumerate}
\end{definizione}

\begin{definizione}
 Data una macchina di Turing $M=\langle Q, \Gamma, b, \delta, q_0, F \rangle$,
 chiamiamo configurazione della macchina una tripla
 $\langle q, S, n \rangle$ dove:
 \begin{enumerate}
  \item $q \in Q$ rappresenta lo stato in cui si trova attualmente la macchina;
  \item $S \in \Gamma ^ \Z$, con $S(k)=b$ per tutti tranne al più finiti $k \in Z$,
  rappresenta lo stato attuale del nastro;
  \item $n \in \Z$ rappresenta la posizione attuale della macchina di Turing
  sul nastro.
 \end{enumerate}
\end{definizione}



\section{Codifica e decodifica}
Sia $L=\{R^{a_1}_1, \ldots, R^{a_s}_s, c_1, \ldots, c_l\}$ un linguaggio.
Vogliamo fornire un modo standard di codificare una $L$-struttura finita $A$ come
stringa binaria, che denoteremo $\bin(A)$. Nel seguito supporremo sempre, senza
perdita di generalità, che
il dominio di una $L$-struttura finita sia un insieme del tipo
$\{1,\ldots,n\} \subseteq \N$.

\begin{definizione}
  Sia $A$ una $L$-struttura, con $|A| = n < +\infty$.
  Se $R \subseteq A^k$ è una relazione,
  definiamo $\bin(R): |A|^k \to \{0,1\}$ come:
  \[\bin(R)(a_1 + a_2 \cdot n + a_k \cdot n^{k-1}):=
    \begin{cases}
      1 \mbox{ se } R(a_1,\ldots,a_k) \\
      0 \mbox{ altrimenti}
    \end{cases}
  \]
  Se $a$ è un elemento di $A=\{1,\ldots,n\}$, definiamo $\bin(a)$ essere la
  scrittura binaria del numero $a$, con eventualmente aggiunti degli zeri a
  sinistra affinché abbia lunghezza esattamente $\lceil \log_2(n) \rceil$.
  Definiamo infine
  \[\bin(A):=\bin(R_1)\string^\ldots\string^\bin(R_s)\string^\bin(c_1)\string^\ldots\string^\bin(c_l).\]
\end{definizione}

\begin{osservazione}
\label{oss-bin}
 Detta $n$ la cardinalità di $A$, la lunghezza della codifica è
 \[ |\bin(A)|=n^{a_1} + \ldots + n^{a_s} + l \cdot \lceil \log_2(n) \rceil, \]
 e in particolare è polinomiale in $n$. Inoltre dato che la parte a destra è
 strettamente crescente in $n$, questo ci dice che, conoscendo solo il linguaggio,
 e $\bin(A)$, possiamo ricavare $n$ e più in generale possiamo ricostruire tutto $A$.
 Infatti avremo che vale $R_i^A(x_1,\ldots, x_{a_i})$ se e solo se
 $\bin(A)(n^{a_1} + \ldots + n^{a_{i-1}} + x_1 + x_2 \cdot n + \ldots + x_{a_i} \cdot n^{a_i-1}) = 1$.
\end{osservazione}
Useremo questa procedura principalmente per descrivere modelli all'interno
di macchine di Turing. Infatti, come notato nell'Osservazione \ref{oss-bin},
una macchina di Turing può ricostruire
il valore della relazione $R_i^A(x_1, \ldots, x_{a_i})$ calcolando il valore
di $n$ e spostando la testina e leggendo il valore nella posizione
$n^{a_1} + \ldots + n^{a_{i-1}} + x_1 + x_2 \cdot n + \ldots + x_{a_i} \cdot n^{a_i-1}$
del blocco di memoria corrispondente alla codifica.
Nello pseudo-codice indicheremo questa procedura con
$\decode_{R_i}(\bin(A), x_1, \ldots, x_{a_i})$. La corrispondente procedura per
leggere il valore di una costante sarà indicata con $\decode_{c_i} (\bin(A))$.

