\chapter{Definizioni}

\section{Sintassi e semantica}

\section{Macchine di Turing deterministiche}
\label{sec:det-TM}
Una macchina di Turing deterministica, detta anche semplicemente macchina di
Turing, può essere immaginata come un dispositivo libero di
muoversi su un nastro infinito sul quale in ogni istante possono essere scritti
finiti simboli appartenenti ad un alfabeto finito. La macchina di Turing è
dotata di uno \emph{stato}, e lavora nel modo seguente:
\begin{enumerate}
 \item Legge il simbolo scritto sul nastro nella posizione in cui si trova attualmente.
 \item Controlla in una tabella finita memorizzata al suo interno cosa deve fare
 nel quando legge quel simbolo nello stato in cui si trova.
 \item Basandosi su quello che ha letto nella tabella scrive un simbolo sul nastro,
 si sposta a destra o a sinistra e passa in un nuovo stato.
 \item Se lo stato in cui si trova ora è uno stato speciale, chiamato \emph{terminale},
 la macchina si ferma. Altrimenti il processo reinizia.
\end{enumerate}
All'istante zero la macchina si trova in uno stato speciale detto \emph{iniziale}
e sul nastro può essere già scritta una stringa finita detta \emph{input} della macchina.
Diamo ora la definizione formale.
\begin{definizione}
Si dice macchina di Turing una tupla
$M=\langle Q, \Gamma, b, \delta, q_0, F, F_y \rangle$ dove:
\begin{enumerate}
 \item $Q$ è un insieme finito non vuoto di \emph{stati};
 \item $\Gamma$ è un insieme finito di simboli, detto \emph{alfabeto} della macchina;
 \item $b \in \Gamma$ è un simbolo speciale, detto \emph{blank}, che rappresenta
 una cella vuota;
 \item $q_0 \in Q$ è lo \emph{stato iniziale};
 \item $F \subseteq Q$ è un insieme di \emph{stati terminali};
 \item $F_y \subseteq F$ è un insieme di stati terminali \emph{accettanti};
 \item $\delta: Q \times \Gamma \to Q \times (\Gamma \setminus \{b\}) \times \{\texttt{L},\texttt{R}\}$
 è una funzione parziale detta \emph{funzione di transizione}.
\end{enumerate}
\end{definizione}

\begin{osservazione}
 Con questa definizione abbiamo scelto di non permettere alla macchina di Turing
 di cancellare una cella (ovvero di scrivere il simbolo blank).
 Questo non modifica la potenza della macchina e permette di definire più facilmente
 lo spazio usato.
\end{osservazione}


\begin{definizione}
 Data una macchina di Turing $M=\langle Q, \Gamma, b, \delta, q_0, F, F_y \rangle$,
 chiamiamo configurazione della macchina una tripla
 $\langle q, S, n \rangle$ dove:
 \begin{enumerate}
  \item $q \in Q$ rappresenta lo stato in cui si trova attualmente la macchina;
  \item $S \in \Gamma ^ \Z$, con $S(k)=b$ per tutti tranne al più finiti $k \in Z$,
  rappresenta lo stato attuale del nastro;
  \item $n \in \Z$ rappresenta la posizione attuale della macchina di Turing
  sul nastro.
 \end{enumerate}
\end{definizione}
Nel seguito useremo la seguente notazione più compatta per descrivere la
configurazione di una macchina di Turing:
\begin{definizione}
\label{def:conf-TM}
 Data una macchina di Turing $M=\langle Q, \Gamma, b, \delta, q_0, F, F_y \rangle$,
 chiamiamo configurazione della macchina una funzione
 $S: \Z \to (\Gamma \sqcup \Gamma \times Q)$  tale che $S(k)=b$ per
 tutti tranne al più finiti $k \in Z$ ed esiste unico $n \in Z$ con
 $S(n) = (\gamma, q) \in \Gamma \times Q$.
 $S$ rappresenta lo il contenuto attuale del nastro, $n$ la posizione della
 macchina di Turing e $q$ il suo stato nella configurazione $S$.
\end{definizione}

\begin{definizione}
 Sia data una macchina di Turing $M=\langle Q, \Gamma, b, \delta, q_0, F, F_y \rangle$
 e due sue configurazioni $S$ e $S'$.
 Siano $n \in \Z$, $\gamma \in \Gamma$, $q \in Q$ gli unici tali che
 $S(n) = (\gamma, q)$ e supponiamo $\delta(\gamma, q) = (q', \gamma', \texttt{R})$.
 Diciamo che
 $M$ può fare la transizione da $S$ a $S'$, e lo indichiamo con $S \vdash_M S'$,
 se 
 \begin{enumerate}
  \item $S'(n)=\gamma'$;
  \item $S'(n+1)=(\sigma, q')$ per un
 qualche $\sigma \in \Gamma$;
  \item $S(k) = S'(k)$ per ogni $k \in \Z$ diverso da
 $n$ e $n+1$.
 \end{enumerate}
 Similmente si dà la definizaione nel caso in cui
 $\delta(\gamma, q) = (q', \gamma', \texttt{L})$,
 sostituendo ovunque $n+1$ con $n-1$.
\end{definizione}

\begin{osservazione}
 Per ogni configurazione $S$ della macchina di Turing $M$, esiste al più una
 $S'$ tale che $S \vdash_M S'$, da cui l'aggettivo \emph{deterministica}.
\end{osservazione}

% \begin{definizione}
%  Data una macchina di Turing $M$ e due sue configurazioni $S$ e $S'$ diciamo
%  che $S \vdash_M^{0} S'$ se $S = S'$ e diciamo che
%  $S \vdash_M^{n+1} S'$ se esiste una configurazione $S_0$ tale che
%  $S \vdash_M S_0$ e $S_0 \vdash_M^{n} S'$. Diciamo poi che $S \vdash_M^{\ast} S'$
%  se esiste $n \in \N$ tale che $S \vdash_M^{n} S'$.
% \end{definizione}

\begin{definizione}
 Una configurazione si dice accettante se lo stato corrispondente è accettante
 oppure se può fare una transizione in una configurazione accettante.
\end{definizione}

\begin{definizione}
 Una configurazione $S$ di una macchina di Turing
 $M=\langle Q, \Gamma, b, \delta, q_0, F \rangle$ si dice \emph{iniziale} se
 $S(0) = (\gamma, q_0)$. In tal caso, il contenuto del nastro
 si dice \emph{input} della macchina di Turing e questo determina totalmente
 una configurazione iniziale.
%  Una configurazione $S$ si dice \emph{terminale} se lo stato della macchina
%  di Turing nella configurazione $S$ è terminale e si dice accettante se lo stato
%  della configurazione è accettante.
\end{definizione}

\begin{definizione}
\label{def:accept-input}
 Sia $S_w$ la configurazione iniziale con input $w \in S^\ast$. Diciamo che
 una macchina di Turing accetta l'input $w$, e lo indichiamo con $M(w)\downarrow_y$
 se la configurazione $S_w$ è accettante.
%  Diciamo che
%  $M$ accetta l'input $w$, e lo indichiamo con $M(w)\downarrow_y$ se
%  esiste $S'$ terminale accettante tale che $S \vdash_M^\ast S'$.
\end{definizione}

\begin{definizione}
 Dato un alfabeto $S$, chiamiamo \emph{problema} un insieme di stringhe finite
 $P \subseteq S^\ast$. Diciamo che il problema $P$ è calcolabile dalla macchina
 di Turing $M$ se, per ogni $w$ in $S^\ast$, $M$ accetta $w$ se e solo se $w$
 è in $P$. Diciamo che il problema $P$ è calcolabile se è calcolabile da una
 macchina di Turing.
\end{definizione}

Esistono varianti della definizione di macchina di Turing che, pur non cambiano
l'insieme dei problemi calcolabili, sono più semplici da adoperare in alcuni
casi. Una variante utile sono le
\emph{macchine di Turing a $k$-nastri}. Queste funzionano esattamente come le
macchine di Turing standard ma ad ogni passaggio leggono e scrivono contemporaneamente su
tutti e $k$ i nastri. La funzione di transizione sarà dunque del tipo
$\delta:  Q \times \Gamma^k \to Q \times ((\Gamma \setminus \{b\}) \times \{\texttt{L},\texttt{R},\texttt{S}\})^k$,
dove il simbolo $\texttt{S}$ indica che la macchina non si sposterà su quel nastro.
Una macchina di Turing a $k$ nastri può chiaramente simulare una macchina di Turing
a un solo nastro. Vale anche il viceversa:

\begin{fatto}
Una macchina di Turing a un solo nastro può simulare una macchina di Turing
a $k$ nastri.
\mytodo{Questo è effettivamente vero ma non abbiamo definito il concetto di simulazione.}
\end{fatto}

Il modello di macchina di Turing che useremo più spesso è quello di una macchina di Turing
con un nastro di input e un nastro di lavoro. Questa segue le stesse regole di
una macchina di Turing a due nastri, fatta eccezione del fatto che non può scrivere
sul nastro di input, ma solo leggere, e che in una sua configurazione iniziale
il nastro di lavoro è sempre vuoto. Se una macchina di Turing di questo tipo
termina con input $w$, definiamo lo spazio di lavoro usato su input $w$
come il numero di celle del nastro di lavoro non vuote nella configurazione terminale.


\section{Macchine di Turing alternanti e non deterministiche}
Una macchina di Turing alternate può essere pensata come una normale macchina di
Turing che ad ogni transizione può ``sdoppiarsi'' e provare più strade contemporaneamente
per risolvere il problema.

\begin{definizione}
 Si dice macchina di Turing alternate una quintupla
 $M=\langle Q, \Gamma, b, \delta, q_0, g \rangle$ dove:
 \begin{itemize}
  \item $Q$ è un insieme finito non vuoto di \emph{stati};
  \item $\Gamma$ è un insieme finito di simboli, detto \emph{alfabeto} della macchina;
  \item $b \in \Gamma$ è un simbolo speciale, detto \emph{blank}, che rappresenta
  una cella vuota;
  \item $\delta: Q \times \Gamma \to \powerset(Q \times \Gamma \times \{L,R\})$;
  \item $q_0 \in Q$ è lo \emph{stato iniziale};
  \item $g: Q \to \{\exists, \forall, \texttt{accept}, \texttt{reject}\}$
  indica per ogni stato se questo è \emph{esistenziale}, \emph{universale},
  \emph{accettante} o \emph{rifiutante}.
 \end{itemize}
\end{definizione}

Definiamo una configurazione della macchina di Turing alternante esattamente
come nella Definizione \ref{def:conf-TM}. Dobbiamo invece apportare alcune lievi
modifiche alla definizione di transizione.
\begin{definizione}
 Sia data una macchina di Turing alternante $M=\langle Q, \Gamma, b, \delta, q_0, g \rangle$
 e due sue configurazioni $S$ e $S'$.
 Siano $n \in \Z$, $\gamma \in \Gamma$, $q \in Q$ gli unici tali che
 $S(n) = (\gamma, q)$ e supponiamo $(q', \gamma', \texttt{R}) \in \delta(\gamma, q)$.
 Diciamo che  $M$ può fare la transizione da $S$ a $S'$, e lo indichiamo con
 $S \vdash_M S'$, se 
 \begin{enumerate}
  \item $S'(n)=\gamma'$;
  \item $S'(n+1)=(\sigma, q')$ per un
 qualche $\sigma \in \Gamma$;
  \item $S(k) = S'(k)$ per ogni $k \in \Z$ diverso da
 $n$ e $n+1$.
 \end{enumerate}
 Similmente si dà la definizaione nel caso in cui
 $(q', \gamma', \texttt{L}) \in \delta(\gamma, q)$,
 sostituendo ovunque $n+1$ con $n-1$.
\end{definizione}

\begin{osservazione}
 Per una generica macchina di Turing alternante non è più vero che per ogni
 configurazione $S$ esiste al più una configurazione $S'$ tale che $S \vdash_M S'$.
\end{osservazione}

\begin{definizione}
 Una configurazione di una macchina di Turing alternante si dice accettante se
 vale una delle seguenti:
 \begin{enumerate}
  \item Il suo stato è accettante;
  \item Il suo stato è esistenziale e la configurazione può fare una transizione
  in uno stato accettante;
  \item Il suo stato è universale e ogni transizione che la configurazione può fare
  finisce in uno stato accettante.
 \end{enumerate}
 Diremo viceversa che la configurazione è rifiutante se vale una delle seguenti:
 \begin{enumerate}
  \item Il suo stato è rifiutante;
  \item Il suo stato è esistenziale e la configurazione può fare una transizione
  solo in stati rifiutanti;
  \item Il suo stato è universale e la configurazione può fare una transizione
  in uno stato accettante.
 \end{enumerate}
\end{definizione}
Possiamo infine definire cosa vuol dire che una macchina di Turing alternante
$M$ accetti un input $w$ allo stesso modo della Definizione \ref{def:accept-input}.

\begin{osservazione}
 Una macchina di Turing deterministica può essere visto come un caso particolare
 di una macchina di Turing alternante dove ogni stato può fare una transizione
 in al più un'altro stato (in tal caso essere universale
 ed esistenziale si equivalgono).
\end{osservazione}

\begin{definizione}
 Chiamiamo macchina di Turing non deterministica una macchina di Turing alternante
 in cui tutti gli stati sono esistenziali, accettanti o rifiutanti.
\end{definizione}

Uno strumento molto utile nello studio delle macchine di Turing alternati è
il grafo $G_w$ associato alla computazione con input $w$. Per costruirlo consideriamo
prima un grafo $(V,E, G_\exists, G_\forall)$ dove:
\begin{itemize}
 \item $V$ è l'insieme dei vertici del grafo e coincide con l'insieme di tutte le
 possibili configurazioni di $M$;
 \item $E$ è una relazione binaria che rappresenta gli archi del grafo, ed è definita
 da $E(S,S') \iff S \vdash_M S'$;
 \item $G_\exists \subseteq V$ è un'etichetta dei nodi che indica le configurazioni
 con stato esistenziale;
 \item $G_\forall \subseteq V$ è un'etichetta dei nodi che indica le configurazioni
 con stato universale.
\end{itemize}


\section{Codifica e decodifica}
Sia $L=\{R^{a_1}_1, \ldots, R^{a_s}_s, c_1, \ldots, c_l\}$ un linguaggio.
Vogliamo fornire un modo standard di codificare una $L$-struttura finita $A$ come
stringa binaria, che denoteremo $\bin(A)$. Nel seguito supporremo sempre, senza
perdita di generalità, che
il dominio di una $L$-struttura finita sia un insieme del tipo
$\{1,\ldots,n\} \subseteq \N$.

\begin{definizione}
  Sia $A$ una $L$-struttura, con $|A| = n < +\infty$.
  Se $R \subseteq A^k$ è una relazione,
  definiamo $\bin(R): |A|^k \to \{0,1\}$ come:
  \[\bin(R)(a_1 + a_2 \cdot n + a_k \cdot n^{k-1}):=
    \begin{cases}
      1 \mbox{ se } R(a_1,\ldots,a_k) \\
      0 \mbox{ altrimenti}
    \end{cases}
  \]
  Se $a$ è un elemento di $A=\{1,\ldots,n\}$, definiamo $\bin(a)$ essere la
  scrittura binaria del numero $a$, con eventualmente aggiunti degli zeri a
  sinistra affinché abbia lunghezza esattamente $\lceil \log_2(n) \rceil$.
  Definiamo infine
  \[\bin(A):=\bin(R_1)\string^\ldots\string^\bin(R_s)\string^\bin(c_1)\string^\ldots\string^\bin(c_l).\]
\end{definizione}

\begin{osservazione}
\label{oss-bin}
 Detta $n$ la cardinalità di $A$, la lunghezza della codifica è
 \[ |\bin(A)|=n^{a_1} + \ldots + n^{a_s} + l \cdot \lceil \log_2(n) \rceil, \]
 e in particolare è polinomiale in $n$. Inoltre dato che la parte a destra è
 strettamente crescente in $n$, questo ci dice che, conoscendo solo il linguaggio,
 e $\bin(A)$, possiamo ricavare $n$ e più in generale possiamo ricostruire tutto $A$.
 Infatti avremo che vale $R_i^A(x_1,\ldots, x_{a_i})$ se e solo se
 $\bin(A)(n^{a_1} + \ldots + n^{a_{i-1}} + x_1 + x_2 \cdot n + \ldots + x_{a_i} \cdot n^{a_i-1}) = 1$.
\end{osservazione}
Useremo questa procedura principalmente per descrivere modelli all'interno
di macchine di Turing. Infatti, come notato nell'Osservazione \ref{oss-bin},
una macchina di Turing può ricostruire
il valore della relazione $R_i^A(x_1, \ldots, x_{a_i})$ calcolando il valore
di $n$ e spostando la testina e leggendo il valore nella posizione
$n^{a_1} + \ldots + n^{a_{i-1}} + x_1 + x_2 \cdot n + \ldots + x_{a_i} \cdot n^{a_i-1}$
del blocco di memoria corrispondente alla codifica.
Nello pseudo-codice indicheremo questa procedura con
$\decode_{R_i}(\bin(A), x_1, \ldots, x_{a_i})$. La corrispondente procedura per
leggere il valore di una costante sarà indicata con $\decode_{c_i} (\bin(A))$.

