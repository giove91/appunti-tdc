\chapter{Classi di complessità}

\section{Introduzione}

In questo capitolo dimostreremo diverse inclusioni interessanti tra le varie classi di complessità. Tali inclusioni possono essere riassunte nel seguente schema:
\begin{IEEEeqnarray*}{CCCCCCC}
  & \DTIME(t(n)) & \subseteq & \NTIME(t(n)) & \subseteq & \ATIME(t(n)) & \subseteq \\
  \subseteq & \DSPACE(t(n)) & \subseteq & \NSPACE(t(n)) & \subseteq & \ASPACE(t(n)) & = \\
  = & \DTIME(O(1)^{t(n)}) & \subseteq & \dots &&&
\end{IEEEeqnarray*}
dove con la notazione $\DTIME(O(1)^{t(n)})$ indichiamo
\[ \bigcup_{c\,>\,0} \DTIME(c^{t(n)}). \]
Oltre a quelle precedentemente rappresentate, vale anche l'inclusione $\NSPACE(t(n)) \subseteq \ATIME(t(n)^2)$.

Le inclusioni presenti sulle righe dello schema sopra sono tutte ovvie: ciò che può essere fatto con una macchina deterministica può essere fatto anche con una macchina non deterministica, e ciò che può essere fatto con una macchina non deterministica può essere fatto anche con una macchina alternante.
Nel resto del capitolo dimostreremo le inclusioni e le uguaglianze rimanenti.

\section{Inclusione tra $\ATIME(t(n))$ e $\DSPACE(t(n))$}

\begin{teorema}
  \label{thm:atime-dspace}
  $\ATIME(t(n)) \subseteq \DSPACE(t(n))$.
\end{teorema}

\begin{proof}
 Data una macchina di Turing alternante $A$ che lavora in $\ATIME(t(n))$, vogliamo trovare
 una macchina di Turing deterministica $B$ che lavori in $\DSPACE(t(n))$ e accetti gli
 stessi input $w$ di $A$. Supponiamo per semplicità di notazione che ogni stato
 non deterministico di $A$ possa fare una transizione in al più due stati.
 Sia $G_w$ il grafo delle computazioni della macchina $A$ su input $w$.
 Esibiamo una macchina di Turing in $\DSPACE(t(n))$ che, preso in input un nodo
 del grafo, decide se quel nodo è accettante o meno. Ciò consente di concludere, poiché
 la macchina $A$ accetta l'input $w$ se e solo se il nodo iniziale
 di $G_w$ è accettante.
 
 La macchina $B$ deve verificare se il nodo iniziale di $G_w$ sia accettante o
 meno. L'idea per fare questo è di visitare ricorsivamente il grafo, che tuttavia
 risulta essere troppo grande per essere salvato interamente in memoria. La soluzione che adottiamo
 è di memorizzare solo il nodo iniziale $c_0$, il nodo $c$ che stiamo attualmente
 visitando e il percorso che abbiamo fatto per raggiungerlo a partire dal nodo
 iniziale, ovvero una stringa binaria $P = \langle b_1, b_2, \ldots, b_n \rangle$
 che ci dica per ogni nodo alternante
 che abbiamo incontrato se ci si è spostati sul primo o sul secondo figlio.
 Teniamo inoltre in memoria un simbolo $D \in \{\texttt{S}, \texttt{N}, \texttt{?}\}$ che ci dice se
 abbiamo già verificato che quel nodo è accettante, non accettante oppure
 se ancora non lo sappiamo.
 
 Si noti che, in particolare, non viene tenuto in memoria il percorso da $c_0$ a $c$.
 Di conseguenza, ogniqualvolta si debba passare da un nodo $c$ al suo padre,
 risulta necessario percorrere nuovamente il cammino da $c_0$ a $c$ (che può essere
 ricostruito grazie alla stringa binaria $P$).
 
 Vediamo ora i dettagli dell'algoritmo di visita ricorsiva del grafo.
 \begin{itemize}
  \item  Se $D$ è uguale a $\texttt{?}$, non abbiamo ancora stabilito se il nodo $c$ sia o meno
  accettante. Pertanto, se $c$ ha dei figli modifichiamo lo stato nel modo seguente:
  \[ P := \langle b_1, b_2, \ldots, b_n, 0 \rangle, \quad D := \texttt{?}, \quad c := \text{figlio sinistro di $c$}. \]
  In caso contrario, $c$ è una foglia. Di conseguenza corrisponde a uno stato in cui la macchina $A$
  ha terminato la computazione, per cui è possibile determinare se si tratti di un
  nodo accettante o non accettante. Modifichiamo allora lo stato in
  \[ P := \langle b_1, b_2, \ldots, b_n \rangle, \quad D := \texttt{S}/\texttt{N}, \quad c := c, \]
  dove $D$ assume il valore \texttt{S} se lo stato $c$ è accettante, mentre assume il valore \texttt{N} se lo stato $c$
  è non accettante.
  
  \item Se $D$ è in $\{\texttt{S}, \texttt{N}\}$ e $P=\langle\rangle$, ci troviamo nel nodo iniziale $c_0$ e sappiamo se tale nodo è accettante. Quindi la computazione di $B$ può terminare, restituendo $D$ come risultato.
  
  \item Se $D$ è in $\{\texttt{S}, \texttt{N}\}$ e $P=\langle b_1, b_2, \ldots, b_n\rangle$ con $n\geq 1$, abbiamo determinato se il nodo corrente $c$ è accettante e dobbiamo continuare la visita dell'albero di computazione.
  \begin{enumerate}
    \item Se $c$ corrisponde ad uno stato esistenziale e $D=\texttt{S}$, allora il padre di $c$ non può che essere accettante, per cui passiamo nello stato
    \[ P := \langle b_1, b_2, \ldots, b_{n-1} \rangle, \quad D := \texttt{S}, \quad c := \text{padre di $c$}. \]
    
    \item Analogamente se $c$ corrisponde ad uno stato universale e $D=\texttt{N}$, il padre di $c$ è sicuramente non accettante, dunque passiamo nello stato
    \[ P := \langle b_1, b_2, \ldots, b_{n-1} \rangle, \quad D := \texttt{N}, \quad c := \text{padre di $c$}. \]
    
    \item Se $b_n=0$ (ovvero $c$ è un figlio sinistro) e non ci troviamo in nessuno dei primi due casi,
    il padre di $c$ è accettante se e solo se il figlio destro del padre di $c$ è accettante.
    Passiamo pertanto nello stato
    \[ P := \langle b_1, b_2, \ldots, b_{n-1}, 1 \rangle, \quad D := \texttt{?}, \quad c := \text{figlio destro del padre di $c$}. \]
    
    \item Se $b_n=1$ (ovvero $c$ è un figlio destro) il padre di $c$ è accettante se e solo se $c$ è accettante.
    Di conseguenza passiamo nello stato
    \[ P := \langle b_1, b_2, \ldots, b_{n-1} \rangle, \quad D := D, \quad c := \text{padre di $c$}. \]
  \end{enumerate}
 \end{itemize}

 Esaminiamo infine la memoria utilizzata dalla macchina di Turing $B$.
 La macchina $A$ lavora in tempo $O(t(n))$, per cui la codifica di un singolo nodo di $G_w$ occupa spazio $O(t(n))$.
 La lunghezza della stringa binaria $P$ è data al massimo dalla profondità del grafo $G_w$, che è sempre $O(t(n))$.
 Infine, memorizzare $D$ richiede spazio $O(1)$.
 Possiamo quindi concludere che la macchina $B$ lavora effettivamente in $\DSPACE(t(n))$.
 
\end{proof}


\section{Uguaglianza tra $\ASPACE(t(n))$ e $\DTIME(O(1)^{t(n)})$}

\begin{teorema}
  \label{thm:aspace-dtime}
  $\ASPACE(t(n)) = \DTIME(O(1)^{t(n)})$.
\end{teorema}

\begin{proof}
  L'inclusione $\ASPACE(t(n)) \subseteq \DTIME(O(1)^{t(n)})$ può essere dimostrata in modo analogo al
  Teorema~\ref{thm:atime-dspace}. Data una macchina di Turing $A$ che lavora in $\ASPACE(t(n))$,
  si costruisce una macchina di Turing $B$ che visita il grafo $G_w$ delle computazioni di $A$ su input $w$
  e determina se $w$ sia o meno accettante per $A$. La dimensione del grafo $G_w$ è $O(1)^{t(n)}$,
  perché il numero di stati accessibili da un singolo stato è limitato da una costante che dipende
  solo da $A$, e non da $w$.
  La visita del grafo può essere effettuata in tempo polinomiale nelle dimensioni del grafo stesso, ad esempio
  come descritto nella dimostrazione del Teorema~\ref{thm:atime-dspace} (oppure in modo più efficiente,
  tenendo in memoria la descrizione di tutti i nodi del percorso dalla radice $c_0$ al nodo corrente $c$,
  cosicché sia più veloce passare da $c$ al padre di $c$).
  Quindi la macchina $B$ lavora effettivamente in $\DTIME(O(1)^{t(n)})$.
  
  Dimostriamo ora l'inclusione $\DTIME(O(1)^{t(n)}) \subseteq \ASPACE(t(n))$.
  Sia $A$ una macchina di Turing che lavora in $\DTIME(c^{t(n)})$ per qualche $c>0$; vogliamo definire una macchina di Turing $B$ che lavori in $\ASPACE(t(n))$, accettando gli stessi input che accetta $A$.
  Possiamo assumere senza perdita di generalità che $A$ abbia un unico nastro.
  L'idea è di definire una subroutine ricorsiva di $B$, che chiamiamo $C(t,p,a)$, al termine della quale $B$ accetta se (nell'esecuzione di $A$ su input $w$) al tempo $t$ in posizione $p$ vi è il simbolo $a$, altrimenti rifiuta.
  Seguiamo la convenzione che $a$ possa appartenere a $\Sigma$ (nel caso in cui non vi sia la testina) oppure a $\Sigma\times Q$ (se vi è la testina, nel qual caso l'elemento di $Q$ indica lo stato attuale della macchina). Vediamo ora i dettagli sull'implementazione di questa subroutine.
  
  L'osservazione principale è che l'esito della chiamata a $C(t,p,a)$ è univocamente determinato dall'esito delle chiamate a $C(t-1,p',a')$ al variare di $p'\in\{p-1,\,p,\,p+1\}$ ed $a'\in \Sigma \,\cup\, \Sigma\times Q$.
%   Più precisamente:
%   \[ C(t+1,p,a) \equiv \exists\; a_{-1}, a_0, a_1 \in \Sigma \,\cup\, \Sigma\times Q \;\left( \right) \]
  Introduciamo uno stato $q_C^\exists$ in cui la macchina $B$ deve iniziare ad eseguire la subroutine $C$.
  Supponiamo che $B$ sia nello stato $q_C^\exists$, e che abbia in memoria (su un apposito nastro di lavoro dedicato all'inizializzazione della subroutine $C$) la terna $(t, p, a)$.
  Se $t=0$, $B$ accetta se e solo se nella posizione $p$ dell'input $w$ (tenendo conto dell'eventuale presenza della testina) vi è il simbolo $a$.
  Se invece $t>0$, $B$ esegue le seguenti operazioni.
  \begin{itemize}
    \item Sceglie (non deterministicamente) tre elementi $a_{-1},a_0,a_1$ in $\Sigma \,\cup\, \Sigma\times Q$.
    \item Verifica se la macchina $A$ con i simboli $a_{-1}, a_0, a_1$ in posizioni $p-1,\,p,\,p+1$ (rispettivamente) avrebbe al passo successivo il simbolo $a$ in posizione $p$.
    In caso affermativo continua, altrimenti rifiuta.
    \item Si porta in uno stato universale e sceglie (non deterministicamente) $i\in\{-1,0,1\}$.
    \item Scrive sul nastro dedicato all'inizializzazione di $C$ la terna $(t-1,p+i,a_i)$ e si riporta nello stato $q_C^\exists$, in modo da chiamare ricorsivamente la subroutine $C$.
  \end{itemize}
  
  L'implementazione della subroutine $C$ è sufficiente per determinare se un qualsiasi input $w$ venga accettato da $A$: basta controllare che al tempo $c^{t(n)}$ la macchina $A$ si trovi nello stato accettante.
  Osserviamo infine che la macchina $B$ che abbiamo definito lavora effettivamente in $\ASPACE(t(n))$, poiché oltre all'input $w$ deve memorizzare solamente le seguenti variabili: un intero $t$ (compreso tra $0$ e $c^{t(n)}$, che quindi occupa $O(t(n))$ bit), un intero $p$ (di modulo $\leq c^{t(n)}$), dei simboli $a,a_{-1},a_0,a_1$ (che occupano $O(1)$ bit), un intero $i$ compreso tra $-1$ e $1$ (che occupa 2 bit).
\end{proof}


\section{Inclusione tra $\NSPACE(t(n))$ e $\ATIME(t(n)^2)$}

Se $G_w$ è il grafo delle computazioni di una macchina di Turing (deterministica, non deterministica o alternante) su input $w$, dati due nodi $x,y$ di $G_w$ scriviamo che $x\vdash y$ se esiste un arco da $x$ a $y$ in $G_w$.
In altre parole, $x\vdash y$ se e solo se è possibile passare dalla configurazione $x$ alla configurazione $y$ usando la tabella di transizione di $A$.

\begin{teorema}
  \label{thm:nspace-atime}
  $\NSPACE(t(n)) = \ATIME(t(n)^2)$, sotto l'ipotesi $t(n) = \Omega(n)$.
\end{teorema}

\begin{proof}
  Sia $A$ una macchina di Turing che lavora in $\NSPACE(t(n))$. Vogliamo definire una macchina $B$ che lavori in $\ATIME(t(n)^2)$ e che accetti gli stessi input che accetta $A$.
  Sia $w$ un input, e sia $G_w$ il grafo delle computazioni di $A$ su input $w$.
  L'idea è di fare in modo che $B$ implementi una subroutine ricorsiva $P(d,x,y)$, al termine della quale $B$ accetta se in $G_w$ esiste un cammino lungo al più $2^d$ dal nodo $x$ al nodo $y$, altrimenti rifiuta.
  
  Entriamo ora maggiormente nei dettagli. Introduciamo uno stato esistenziale $q_P^\exists$, in cui $B$ inizia l'esecuzione della subroutine $P$ leggendo le variabili $d,x,y$ da un apposito nastro.
  Se $d=0$, la macchina $B$ accetta nel caso in cui $x=y$ oppure $x\vdash y$, altrimenti rifiuta.
  Se invece $d>0$, $B$ esegue le seguenti operazioni.
  \begin{itemize}
    \item Si porta in uno stato esistenziale e sceglie (non deterministicamente) un nodo $z$ di $G_w$.
    Tale $z$ rappresenta un possibile nodo intermedio in un eventuale percorso da $x$ a $y$.
    \item Si porta in uno stato universale e sceglie (non deterministicamente) un bit $b\in\{0,1\}$.
    Tale bit determina se verificare l'esistenza di un percorso da $x$ a $z$ oppure se verificare l'esistenza di un percorso da $z$ a $y$.
    \item Se $b=0$, si porta nello stato $q_P^\exists$ inizializzando $P$ con le variabili $(d,x,z)$. Se invece $b=1$, si porta nel medesimo stato ma inizializzando $P$ con le variabili $(d,z,y)$.
    Da questo momento in avanti, l'esecuzione continua ricorsivamente.
  \end{itemize}
  La procedura descritta ha l'effetto desiderato, perché l'esistenza di un percorso da $x$ a $y$ in $\leq 2^d$ passi è equivalente all'esistenza di un nodo intermedio $z$ per cui si possa andare da $x$ a $z$ in $\leq 2^{d-1}$ passi e da $z$ a $y$ in $\leq 2^{d-1}$ passi.
  
  La subroutine $P$ è sufficiente per decidere se un input $w$ venga accettato da $A$, poiché basta che $B$ chiami $P$ con i seguenti parametri:
  \begin{itemize}
    \renewcommand{\labelitemi}{--}
    \item $x = $ configurazione iniziale di $A$ su input $w$;
    \item $y = $ configurazione finale accettante di $A$;
    \item $d = $ logaritmo della profondità del grafo $G_w$.
  \end{itemize}
  Si noti che la profondità del grafo $G_w$ è al massimo $c^{t(n)}$ per qualche costante $c>0$ (che dipende da $A$ ma non da $w$), quindi $d=O(t(n))$.
  
  Verifichiamo infine che $B$ lavori effettivamante in $\ATIME(t(n)^2)$.
  Per quanto appena osservato, il numero di chiamate alla subroutine $P$ è $O(t(n))$.
  Ciascuna delle chiamate (compresa quella finale con $d=0$) impiega tempo $O(t(n))$, perché la lunghezza della codifica di un qualsiasi nodo di $G_w$ è $O(t(n))$.
  Quindi il tempo totale di esecuzione è effettivamente $O(t(n)^2)$.
\end{proof}


\section{Alcune conseguenze}

\begin{corollario}
  $\NPSPACE \subseteq \APTIME$.
\end{corollario}

\begin{proof}
  È sufficiente applicare il Teorema \ref{thm:nspace-atime}, osservando che il quadrato di un polinomio è ancora un polinomio.
\end{proof}


\begin{corollario}
  \label{cor:npspace-dpspace}
  $\NPSPACE = \DPSPACE$.
\end{corollario}

\begin{proof}
  Abbiamo che $\NSPACE(t(n))\subseteq \ATIME(t(n)^2) \subseteq \DSPACE(t(n)^2)$.
  Dal momento che il quadrato di un polinomio è ancora un polinomio, ne deduciamo che $\NPSPACE = \DPSPACE$.
\end{proof}

Quindi il problema P vs NP è molto più semplice da risolvere rimpiazzando il tempo con lo spazio.


