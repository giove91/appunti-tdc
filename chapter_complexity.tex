\chapter{Classi di complessità}

\section{ATIME}

\begin{teorema}
  \label{thm:atime-dspace}
  $\ATIME(t(n)) \subseteq \DSPACE(t(n))$.
\end{teorema}

\begin{proof}
 Sia $A$ una macchina di Turing alternante in $\ATIME(t(n))$, vogliamo trovare
 una macchina di Turing deterministica $B$ in $\DSPACE(t(n))$ che accetti gli
 stessi input $w$ di $A$. Supponiamo per semplicità di notazione che ogni stato
 non deterministico di $A$ possa fare una transizione in al più due stati.
 Sia $G_w$ il grafo delle computazioni della macchina $A$ quando riceve input $w$.
 Ricordiamo che, per definizione, un nodo del grafo è accettante se vale una delle
 seguenti condizioni: \mytodo{ricordare la definizione è una cosa che non farei,
 basta che da qualche parte sia definita una macchina di Turing alternante...}
 \begin{itemize}
  \item è esistenziale e almeno uno dei suoi figli è accettante;
  \item è universale ed entrambi i suoi figli sono accettanti.
 \end{itemize}
 Esibiamo una macchina di Turing in $\DSPACE(t(n))$ che, preso in input un nodo
 del grafo, decide se quel nodo è accettante o meno. Ciò consente di concludere, poiché
 la macchina $A$ accetta l'input $w$ se e solo se il nodo iniziale
 di $G_w$ è accettante.
 
 La macchina $B$ deve verificare se il nodo iniziale di $G_w$ sia accettante o
 meno. L'idea per fare questo è di visitare ricorsivamente il grafo, che tuttavia
 risulta essere troppo grande per essere salvato interamente in memoria. La soluzione che adottiamo
 è di memorizzare solo il nodo iniziale $c_0$, il nodo $c$ che stiamo attualmente
 visitando e il percorso che abbiamo fatto per raggiungerlo a partire dal nodo
 iniziale, ovvero una stringa binaria $P = \langle b_1, b_2, \ldots, b_n \rangle$
 che ci dica per ogni nodo alternante
 che abbiamo incontrato se ci si è spostati sul primo o sul secondo figlio.
 Teniamo inoltre in memoria un simbolo $D \in \{\texttt{S}, \texttt{N}, \texttt{?}\}$ che ci dice se
 abbiamo già verificato che quel nodo è accettante, non accettante oppure
 se ancora non lo sappiamo.
 
 Si noti che, in particolare, non viene tenuto in memoria il percorso da $c_0$ a $c$.
 Di conseguenza, ogniqualvolta si debba passare da un nodo $c$ al suo padre,
 risulta necessario percorrere nuovamente il cammino da $c_0$ a $c$ (che può essere
 ricostruito grazie alla stringa binaria $P$).
 
 Vediamo ora i dettagli dell'algoritmo di visita ricorsiva del grafo.
 \begin{itemize}
  \item  Se $D$ è uguale a $\texttt{?}$, non abbiamo ancora stabilito se il nodo $c$ sia o meno
  accettante. Pertanto, se $c$ ha dei figli modifichiamo lo stato nel modo seguente:
  \[ P := \langle b_1, b_2, \ldots, b_n, 0 \rangle, \quad D := \texttt{?}, \quad c := \text{figlio sinistro di $c$}. \]
  In caso contrario, $c$ è una foglia. Di conseguenza corrisponde a uno stato in cui la macchina $A$
  ha terminato la computazione, per cui è possibile determinare se si tratti di un
  nodo accettante o non accettante. Modifichiamo allora lo stato in
  \[ P := \langle b_1, b_2, \ldots, b_n \rangle, \quad D := \texttt{S}/\texttt{N}, \quad c := c, \]
  dove $D$ assume il valore \texttt{S} se lo stato $c$ è accettante, mentre assume il valore \texttt{N} se lo stato $c$
  è non accettante.
  
  \item Se $D$ è in $\{\texttt{S}, \texttt{N}\}$ e $P=\langle\rangle$, ci troviamo nel nodo iniziale $c_0$ e sappiamo se tale nodo è accettante. Quindi la computazione di $B$ può terminare, restituendo $D$ come risultato.
  
  \item Se $D$ è in $\{\texttt{S}, \texttt{N}\}$ e $P=\langle b_1, b_2, \ldots, b_n\rangle$ con $n\geq 1$, abbiamo determinato se il nodo corrente $c$ è accettante e dobbiamo continuare la visita dell'albero di computazione.
  \begin{enumerate}
    \item Se $c$ corrisponde ad uno stato esistenziale e $D=\texttt{S}$, allora il padre di $c$ non può che essere accettante, per cui passiamo nello stato
    \[ P := \langle b_1, b_2, \ldots, b_{n-1} \rangle, \quad D := \texttt{S}, \quad c := \text{padre di $c$}. \]
    
    \item Analogamente se $c$ corrisponde ad uno stato universale e $D=\texttt{N}$, il padre di $c$ è sicuramente non accettante, dunque passiamo nello stato
    \[ P := \langle b_1, b_2, \ldots, b_{n-1} \rangle, \quad D := \texttt{N}, \quad c := \text{padre di $c$}. \]
    
    \item Se $b_n=0$ (ovvero $c$ è un figlio sinistro) e non ci troviamo in nessuno dei primi due casi,
    il padre di $c$ è accettante se e solo se il figlio destro del padre di $c$ è accettante.
    Passiamo pertanto nello stato
    \[ P := \langle b_1, b_2, \ldots, b_{n-1}, 1 \rangle, \quad D := \texttt{?}, \quad c := \text{figlio destro del padre di $c$}. \]
    
    \item Se $b_n=1$ (ovvero $c$ è un figlio destro) il padre di $c$ è accettante se e solo se $c$ è accettante.
    Di conseguenza passiamo nello stato
    \[ P := \langle b_1, b_2, \ldots, b_{n-1} \rangle, \quad D := D, \quad c := \text{padre di $c$}. \]
  \end{enumerate}
 \end{itemize}

 Esaminiamo infine la memoria utilizzata dalla macchina di Turing $B$.
 La macchina $A$ lavora in tempo $O(t(n))$, per cui la codifica di un singolo nodo di $G_w$ occupa spazio $O(t(n))$.
 La lunghezza della stringa binaria $P$ è data al massimo dalla profondità del grafo $G_w$, che è sempre $O(t(n))$.
 Infine, memorizzare $D$ richiede spazio $O(1)$.
 Possiamo quindi concludere che la macchina $B$ lavora effettivamente in $\DSPACE(t(n))$.
 
\end{proof}


\begin{teorema}
   $\ASPACE(t(n)) = \DTIME(O(1)^{t(n)})$, dove il membro di destra può essere scritto in modo più preciso
   come
   \[ \bigcup_{c\,>\,0} \DTIME(c^{t(n)}). \]
\end{teorema}

\begin{proof}
  L'inclusione $\ASPACE(t(n)) \subseteq \DTIME(O(1)^{t(n)})$ può essere dimostrata in modo analogo al
  Teorema~\ref{thm:atime-dspace}. Data una macchina di Turing $A$ che lavora in $\ASPACE(t(n))$,
  si costruisce una macchina di Turing $B$ che visita il grafo $G_w$ delle computazioni di $A$ su input $w$
  e determina se $w$ sia o meno accettante per $A$. La dimensione del grafo $G_w$ è $O(1)^{t(n)}$,
  perché il numero di stati accessibili da un singolo stato è limitato da una costante che dipende
  solo da $A$, e non da $w$.
  La visita del grafo può essere effettuata in tempo polinomiale nelle dimensioni del grafo stesso, ad esempio
  come descritto nella dimostrazione del Teorema~\ref{thm:atime-dspace} (oppure in modo più efficiente,
  tenendo in memoria la descrizione di tutti i nodi del percorso dalla radice $c_0$ al nodo corrente $c$,
  cosicché sia più veloce passare da $c$ al padre di $c$).
  Quindi la macchina $B$ lavora effettivamente in $\DTIME(O(1)^{t(n)})$.
\end{proof}


