\chapter{Classi di complessità}

\section{ATIME}

\begin{teorema}
  \label{thm:atime-dspace}
  $\ATIME(t(n)) \subseteq \DSPACE(t(n))$.
\end{teorema}

\begin{proof}
 Sia $A$ una macchina di Turing alternante in $\ATIME(t(n))$, vogliamo trovare
 una macchina di Turing deterministica $B$ in $\DSPACE(t(n))$ che accetti gli
 stessi input $w$ di $A$. Supponiamo per semplicità di notazione che ogni stato
 non deterministico di $A$ possa fare una transizione in al più due stati.
 Sia $G_w$ il grafo delle computazioni della macchina $A$ quando riceve input $w$.
 Ricordiamo che, per definizione, un nodo del grafo è accettante se vale una delle
 seguenti condizioni: \mytodo{ricordare la definizione è una cosa che non farei,
 basta che da qualche parte sia definita una macchina di Turing alternante...}
 \begin{itemize}
  \item è esistenziale e almeno uno dei suoi figli è accettante;
  \item è universale ed entrambi i suoi figli sono accettanti.
 \end{itemize}
 Esibiamo una macchina di Turing in $\DSPACE(t(n))$ che, preso in input un nodo
 del grafo, decide se quel nodo è accettante o meno. Ciò consente di concludere, poiché
 la macchina $A$ accetta l'input $w$ se e solo se il nodo iniziale
 di $G_w$ è accettante.
 
 La macchina $B$ deve verificare se il nodo iniziale di $G_w$ sia accettante o
 meno. L'idea per fare questo è di visitare ricorsivamente il grafo, che tuttavia
 risulta essere troppo grande per essere salvato interamente in memoria. La soluzione che adottiamo
 è di memorizzare solo il nodo iniziale $c_0$, il nodo $c$ che stiamo attualmente
 visitando e il percorso che abbiamo fatto per raggiungerlo a partire dal nodo
 iniziale, ovvero una stringa binaria $P = \langle b_1, b_2, \ldots, b_n \rangle$
 che ci dica per ogni nodo alternante
 che abbiamo incontrato se ci si è spostati sul primo o sul secondo figlio.
 Teniamo inoltre in memoria un simbolo $D \in \{\texttt{S}, \texttt{N}, \texttt{?}\}$ che ci dice se
 abbiamo già verificato che quel nodo è accettante, non accettante oppure
 se ancora non lo sappiamo.
 
 Si noti che, in particolare, non viene tenuto in memoria il percorso da $c_0$ a $c$.
 Di conseguenza, ogniqualvolta si debba passare da un nodo $c$ al suo padre,
 risulta necessario percorrere nuovamente il cammino da $c_0$ a $c$ (che può essere
 ricostruito grazie alla stringa binaria $P$).
 
 Vediamo ora i dettagli dell'algoritmo di visita ricorsiva del grafo.
 \begin{itemize}
  \item  Se $D$ è uguale a $\texttt{?}$, non abbiamo ancora stabilito se il nodo $c$ sia o meno
  accettante. Pertanto, se $c$ ha dei figli modifichiamo lo stato nel modo seguente:
  \[ P := \langle b_1, b_2, \ldots, b_n, 0 \rangle, \quad D := \texttt{?}, \quad c := \text{figlio sinistro di $c$}. \]
  In caso contrario, $c$ è una foglia. Di conseguenza corrisponde a uno stato in cui la macchina $A$
  ha terminato la computazione, per cui è possibile determinare se si tratti di un
  nodo accettante o non accettante. Modifichiamo allora lo stato in
  \[ P := \langle b_1, b_2, \ldots, b_n \rangle, \quad D := \texttt{S}/\texttt{N}, \quad c := c, \]
  dove $D$ assume il valore \texttt{S} se lo stato $c$ è accettante, mentre assume il valore \texttt{N} se lo stato $c$
  è non accettante.
  
  \item Se $D$ è in $\{\texttt{S}, \texttt{N}\}$ e $P=\langle\rangle$, ci troviamo nel nodo iniziale $c_0$ e sappiamo se tale nodo è accettante. Quindi la computazione di $B$ può terminare, restituendo $D$ come risultato.
  
  \item Se $D$ è in $\{\texttt{S}, \texttt{N}\}$ e $P=\langle b_1, b_2, \ldots, b_n\rangle$ con $n\geq 1$, abbiamo determinato se il nodo corrente $c$ è accettante e dobbiamo continuare la visita dell'albero di computazione.
  \begin{enumerate}
    \item Se $c$ corrisponde ad uno stato esistenziale e $D=\texttt{S}$, allora il padre di $c$ non può che essere accettante, per cui passiamo nello stato
    \[ P := \langle b_1, b_2, \ldots, b_{n-1} \rangle, \quad D := \texttt{S}, \quad c := \text{padre di $c$}. \]
    
    \item Analogamente se $c$ corrisponde ad uno stato universale e $D=\texttt{N}$, il padre di $c$ è sicuramente non accettante, dunque passiamo nello stato
    \[ P := \langle b_1, b_2, \ldots, b_{n-1} \rangle, \quad D := \texttt{N}, \quad c := \text{padre di $c$}. \]
    
    \item Se $b_n=0$ (ovvero $c$ è un figlio sinistro) e non ci troviamo in nessuno dei primi due casi,
    il padre di $c$ è accettante se e solo se il figlio destro del padre di $c$ è accettante.
    Passiamo pertanto nello stato
    \[ P := \langle b_1, b_2, \ldots, b_{n-1}, 1 \rangle, \quad D := \texttt{?}, \quad c := \text{figlio destro del padre di $c$}. \]
    
    \item Se $b_n=1$ (ovvero $c$ è un figlio destro) il padre di $c$ è accettante se e solo se $c$ è accettante.
    Di conseguenza passiamo nello stato
    \[ P := \langle b_1, b_2, \ldots, b_{n-1} \rangle, \quad D := D, \quad c := \text{padre di $c$}. \]
  \end{enumerate}
 \end{itemize}

 Esaminiamo infine la memoria utilizzata dalla macchina di Turing $B$.
 La macchina $A$ lavora in tempo $O(t(n))$, per cui la codifica di un singolo nodo di $G_w$ occupa spazio $O(t(n))$.
 La lunghezza della stringa binaria $P$ è data al massimo dalla profondità del grafo $G_w$, che è sempre $O(t(n))$.
 Infine, memorizzare $D$ richiede spazio $O(1)$.
 Possiamo quindi concludere che la macchina $B$ lavora effettivamente in $\DSPACE(t(n))$.
 
\end{proof}


\begin{teorema}
   $\ASPACE(t(n)) = \DTIME(O(1)^{t(n)})$, dove il membro di destra può essere scritto in modo più preciso
   come
   \[ \bigcup_{c\,>\,0} \DTIME(c^{t(n)}). \]
\end{teorema}

\begin{proof}
  L'inclusione $\ASPACE(t(n)) \subseteq \DTIME(O(1)^{t(n)})$ può essere dimostrata in modo analogo al
  Teorema~\ref{thm:atime-dspace}. Data una macchina di Turing $A$ che lavora in $\ASPACE(t(n))$,
  si costruisce una macchina di Turing $B$ che visita il grafo $G_w$ delle computazioni di $A$ su input $w$
  e determina se $w$ sia o meno accettante per $A$. La dimensione del grafo $G_w$ è $O(1)^{t(n)}$,
  perché il numero di stati accessibili da un singolo stato è limitato da una costante che dipende
  solo da $A$, e non da $w$.
  La visita del grafo può essere effettuata in tempo polinomiale nelle dimensioni del grafo stesso, ad esempio
  come descritto nella dimostrazione del Teorema~\ref{thm:atime-dspace} (oppure in modo più efficiente,
  tenendo in memoria la descrizione di tutti i nodi del percorso dalla radice $c_0$ al nodo corrente $c$,
  cosicché sia più veloce passare da $c$ al padre di $c$).
  Quindi la macchina $B$ lavora effettivamente in $\DTIME(O(1)^{t(n)})$.
  
  Dimostriamo ora l'inclusione $\DTIME(O(1)^{t(n)}) \subseteq \ASPACE(t(n))$.
  Sia $A$ una macchina di Turing che lavora in $\DTIME(c^{t(n)})$ per qualche $c>0$; vogliamo definire una macchina di Turing $B$ che lavori in $\ASPACE(t(n))$, accettando gli stessi input che accetta $A$.
  Possiamo assumere senza perdita di generalità che $A$ abbia un unico nastro.
  L'idea è di definire una subroutine ricorsiva di $B$, che chiamiamo $C(t,p,a)$, la quale restituisce \texttt{True} se (nell'esecuzione di $A$ su input $w$) al tempo $t$ in posizione $p$ vi è il simbolo $a$, altrimenti restituisce \texttt{False}.
  Seguiamo la convenzione che $a$ possa appartenere a $\Sigma$ (nel caso in cui non vi sia la testina) oppure a $\Sigma\times Q$ (se vi è la testina, nel qual caso l'elemento di $Q$ indica lo stato attuale della macchina). Vediamo ora i dettagli sull'implementazione di questa subroutine.
  
  L'osservazione principale è che $C(t,p,a)$ è univocamente determinata da $C(t-1,p',a')$ al variare di $p'\in\{p-1,\,p,\,p+1\}$ ed $a'\in \Sigma \,\cup\, \Sigma\times Q$.
%   Più precisamente:
%   \[ C(t+1,p,a) \equiv \exists\; a_{-1}, a_0, a_1 \in \Sigma \,\cup\, \Sigma\times Q \;\left( \right) \]
  Introduciamo uno stato $q_C^\exists$ in cui la macchina $B$ deve iniziare ad eseguire la subroutine $C$.
  Supponiamo che $B$ sia nello stato $q_C^\exists$, e che abbia in memoria (su un apposito nastro di lavoro dedicato all'inizializzazione della subroutine $C$) la terna $(t, p, a)$.
  Se $t=0$, la subroutine restituisce \texttt{True} se e solo se nella posizione $p$ dell'input $w$ (tenendo conto dell'eventuale presenza della testina) vi è il simbolo $a$.
  Se invece $t>0$, $B$ esegue le seguenti operazioni.
  \begin{itemize}
    \item Sceglie (non deterministicamente) tre elementi $a_{-1},a_0,a_1$ in $\Sigma \,\cup\, \Sigma\times Q$.
    \item Verifica se la macchina $A$ con i simboli $a_{-1}, a_0, a_1$ in posizioni $p-1,\,p,\,p+1$ (rispettivamente) avrebbe al passo successivo il simbolo $a$ in posizione $p$.
    In caso affermativo continua, altrimenti ritorna \texttt{False}.
    \item Si porta in uno stato universale e sceglie (non deterministicamente) $i\in\{-1,0,1\}$.
    \item Scrive sul nastro dedicato all'inizializzazione di $C$ la terna $(t-1,p+i,a_i)$ e si riporta nello stato $q_C^\exists$, in modo da chiamare ricorsivamente la subroutine $C$.
  \end{itemize}
  
  L'implementazione della subroutine $C$ è sufficiente per determinare se un qualsiasi input $w$ venga accettato da $A$: basta controllare che al tempo $c^{t(n)}$ la macchina $A$ si trovi nello stato accettante.
  Osserviamo infine che la macchina $B$ che abbiamo definito lavora effettivamente in $\ASPACE(t(n))$, poiché oltre all'input $w$ deve memorizzare solamente le seguenti variabili: un intero $t$ (compreso tra $0$ e $c^{t(n)}$, che quindi occupa $O(t(n))$ bit), un intero $p$ (di modulo $\leq c^{t(n)}$), dei simboli $a,a_{-1},a_0,a_1$ (che occupano $O(1)$ bit), un intero $i$ compreso tra $-1$ e $1$ (che occupa 2 bit).
\end{proof}


